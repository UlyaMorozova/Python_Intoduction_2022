1.	Создайте равномерное разбиение интервала от -1.3 до 2.5 на 64 отрезка.


```python
import numpy as np
np.linspace(-1.3, 2.5, 64)

```




    array([-1.3       , -1.23968254, -1.17936508, -1.11904762, -1.05873016,
           -0.9984127 , -0.93809524, -0.87777778, -0.81746032, -0.75714286,
           -0.6968254 , -0.63650794, -0.57619048, -0.51587302, -0.45555556,
           -0.3952381 , -0.33492063, -0.27460317, -0.21428571, -0.15396825,
           -0.09365079, -0.03333333,  0.02698413,  0.08730159,  0.14761905,
            0.20793651,  0.26825397,  0.32857143,  0.38888889,  0.44920635,
            0.50952381,  0.56984127,  0.63015873,  0.69047619,  0.75079365,
            0.81111111,  0.87142857,  0.93174603,  0.99206349,  1.05238095,
            1.11269841,  1.17301587,  1.23333333,  1.29365079,  1.35396825,
            1.41428571,  1.47460317,  1.53492063,  1.5952381 ,  1.65555556,
            1.71587302,  1.77619048,  1.83650794,  1.8968254 ,  1.95714286,
            2.01746032,  2.07777778,  2.13809524,  2.1984127 ,  2.25873016,
            2.31904762,  2.37936508,  2.43968254,  2.5       ])



2.	Сгенерируйте numpy массив длины $3n$, заполненный циклически числами 1, 2, 3, 1, 2, 3, 1....


```python
mas = np.array([1, 2, 3])
n = int(input())
mas = np.tile(mas, (n,))
mas
```

    4
    




    array([1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3])



3.	Создайте массив первых 10 нечетных целых чисел.


```python
mas = np.arange(20)
mas[mas%2==1]
```




    array([ 1,  3,  5,  7,  9, 11, 13, 15, 17, 19])



4.  Создайте массив нулей размера 10 x 10, а затем создайте в нём "рамку" из единиц по краям.


```python
mas = np.zeros([10, 10])
mas[[0,-1],:]=1
mas[:,[0,-1]]=1
mas
```




    array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]])



5.  Создайте массив 8 x 8 с шахматной доской из нулей и единиц.


```python
mas = np.zeros([8,8])
mas[0::2,1::2]=1
mas[1::2,0::2]=1
mas
```




    array([[0., 1., 0., 1., 0., 1., 0., 1.],
           [1., 0., 1., 0., 1., 0., 1., 0.],
           [0., 1., 0., 1., 0., 1., 0., 1.],
           [1., 0., 1., 0., 1., 0., 1., 0.],
           [0., 1., 0., 1., 0., 1., 0., 1.],
           [1., 0., 1., 0., 1., 0., 1., 0.],
           [0., 1., 0., 1., 0., 1., 0., 1.],
           [1., 0., 1., 0., 1., 0., 1., 0.]])



6.  Создайте функцию, которая создает $n×n$ матрицу с $(i,j)$-элементом, равным $i+j$.


```python
def fun(n,m):
    rez=n+m
    return rez
n = int(input())
A = np.fromfunction(fun, (n, n), dtype=int)
A
```

    6
    




    array([[ 0,  1,  2,  3,  4,  5],
           [ 1,  2,  3,  4,  5,  6],
           [ 2,  3,  4,  5,  6,  7],
           [ 3,  4,  5,  6,  7,  8],
           [ 4,  5,  6,  7,  8,  9],
           [ 5,  6,  7,  8,  9, 10]])



7. Примените функцию dot для перемножения вектор на вектор, матрицу на вектор и матрицу на матрицу.


```python
a = np.array([12, 5, 6, 15, 17])
b = np.array([1, 9, 10, 18, 3])
np.dot(a,b)

```




    438




```python
A = np.random.randint(20, size = (3,5))
A
```




    array([[18,  3,  6,  4, 11],
           [ 9, 12, 18, 15, 16],
           [ 1, 18,  9,  4, 15]])




```python
B = np.random.randint(20, size = (5,4))
B
```




    array([[ 1,  8, 17,  1],
           [15, 18,  6,  9],
           [ 8, 15,  6, 17],
           [10,  8, 16,  4],
           [17, 10, 10, 14]])




```python
np.dot(A,a)
```




    array([514, 773, 471])




```python
np.dot(A,B)
```




    array([[338, 430, 534, 317],
           [755, 838, 733, 707],
           [638, 649, 393, 542]])



8. Вычислите cos(x) и sin(x) на интервале [0,1] с шагом $0.05$, а затем объедините оба массива чисел как строки в один массив.


```python
sc = np.arange(0, 1.05, 0.05)
S = np.sin(sc)
C = np.cos(sc)
SC = np.hstack((S,C))
SC
```




    array([0.        , 0.04997917, 0.09983342, 0.14943813, 0.19866933,
           0.24740396, 0.29552021, 0.34289781, 0.38941834, 0.43496553,
           0.47942554, 0.52268723, 0.56464247, 0.60518641, 0.64421769,
           0.68163876, 0.71735609, 0.75128041, 0.78332691, 0.8134155 ,
           0.84147098, 1.        , 0.99875026, 0.99500417, 0.98877108,
           0.98006658, 0.96891242, 0.95533649, 0.93937271, 0.92106099,
           0.9004471 , 0.87758256, 0.85252452, 0.82533561, 0.7960838 ,
           0.76484219, 0.73168887, 0.69670671, 0.65998315, 0.62160997,
           0.58168309, 0.54030231])



9. Создайте матрицу $A$ размера $3×5$ из случайных чисел с равномерным распределением на отрезке $[-1,3]$ (используйте np.random.rand)


```python
import numpy as np
A = (3 - (-1)) * np.random.random_sample((3, 5)) + (-1)
A
```




    array([[-0.72040741,  2.77909843,  0.44941085,  1.58355627,  1.66266161],
           [-0.88545464,  2.00916576,  1.07122582,  2.31856923,  0.80288493],
           [ 0.62826264, -0.51632832,  2.37540098, -0.13858178,  0.11538585]])



10. Найдите сумму всех элементов, сумму внутри строк, сумму внутри столбцов, а также среднее значение, дисперсию и стандартное отклонение чисел для каждой строки матрицы $A$. (Подобно тому, как sorted имеет необязательный аргумент key=, многие функции Numpy имеют необязательный аргумент axis=)



```python
A.sum()
```




    13.534850228495912




```python
A.sum(axis=0) #Сумма по столбцам
```




    array([-0.97759941,  4.27193587,  3.89603765,  3.76354373,  2.58093239])




```python
A.sum(axis=1) #Сумма по строкам
```




    array([5.75431975, 5.3163911 , 2.46413938])




```python
np.mean(A, axis=1) #Среднее по строкам
```




    array([1.15086395, 1.06327822, 0.49282788])




```python
np.var(A, axis=1)
```




    array([1.41879999, 1.26717727, 1.02439218])




```python
np.std(A, axis=1)
```




    array([1.19113391, 1.12568969, 1.01212261])



11.  Отнимите от каждого элемента матрицы $A$ среднее по строке и поделите на стандартное отклонение строки.


```python
(A - A.mean(axis=1).reshape(-1,1))/A.std(axis=1).reshape(-1,1)
# Reshape нужен чтобы восстановить размер массива, полученного путем A.mean, иначе выдаст ошибку
```




    array([[-1.57099999,  1.36696174, -0.58889525,  0.36326085,  0.42967264],
           [-1.7311457 ,  0.84027379,  0.0070602 ,  1.1151306 , -0.23131889],
           [ 0.13381261, -0.99706911,  1.86002474, -0.623847  , -0.37292124]])




```python
a = A.mean(axis=1)
a.shape
```




    (3,)




```python
a = A.mean(axis=1).reshape(-1,1)
a.shape
```




    (3, 1)



12. Отсортируйте матрицу $A$ по 3-ому столбцу, т.е. поменяйте местами строки матрицы так, чтобы 3-й столбец оказался отсортированным. Используйте для этого slicing + argsort + indexing.


```python
A[A[:, 2].argsort()]
```




    array([[-0.72040741,  2.77909843,  0.44941085,  1.58355627,  1.66266161],
           [-0.88545464,  2.00916576,  1.07122582,  2.31856923,  0.80288493],
           [ 0.62826264, -0.51632832,  2.37540098, -0.13858178,  0.11538585]])



13. Посчитайте две матрицы: $B = A^TA$ и $C = AA^T$. Что вы можете о них сказать? Какого они размера? В чём их сходство и отличие?


```python
B = np.dot(A.T, A)
B
```




    array([[ 1.69773071, -4.10549804,  0.22009492, -3.28085932, -1.83621931],
           [-4.10549804, 12.02673006,  2.17474043,  9.13080236,  6.1742522 ],
           [ 0.22009492,  2.17474043,  6.99202468,  2.86619129,  1.8813769 ],
           [-3.28085932,  9.13080236,  2.86619129,  7.90261867,  4.47847215],
           [-1.83621931,  6.1742522 ,  1.8813769 ,  4.47847215,  3.42238173]])




```python
C = np.dot(A, A.T)
C
```




    array([[13.71643912, 11.7094888 , -0.84760572],
           [11.7094888 , 11.98868922,  0.72223372],
           [-0.84760572,  0.72223372,  6.3363575 ]])



14. Найдите сумму диагональных элементов матриц $B$ и $C$.


```python
np.trace(B)
```




    32.041485842885706




```python
np.trace(C)
```




    32.041485842885706




```python
# Они одинаковы, Карл!
```

15.	Посчитайте детерминант и ранг матриц $A$, $B$ и $C$, посмотрите на спектр (набор собственных значений) матриц $B$ и $C$, какие выводы вы можете сделать?  
(подсказка: используйте готовые функции из библиотеки np.linalg). 



```python
import numpy.linalg as lg
lg.det(A)
```


    ---------------------------------------------------------------------------

    LinAlgError                               Traceback (most recent call last)

    Input In [41], in <cell line: 2>()
          1 import numpy.linalg as lg
    ----> 2 lg.det(A)
    

    File <__array_function__ internals>:5, in det(*args, **kwargs)
    

    File D:\Anaconda\lib\site-packages\numpy\linalg\linalg.py:2155, in det(a)
       2153 a = asarray(a)
       2154 _assert_stacked_2d(a)
    -> 2155 _assert_stacked_square(a)
       2156 t, result_t = _commonType(a)
       2157 signature = 'D->D' if isComplexType(t) else 'd->d'
    

    File D:\Anaconda\lib\site-packages\numpy\linalg\linalg.py:203, in _assert_stacked_square(*arrays)
        201 m, n = a.shape[-2:]
        202 if m != n:
    --> 203     raise LinAlgError('Last 2 dimensions of the array must be square')
    

    LinAlgError: Last 2 dimensions of the array must be square



```python
lg.det(B)
```




    8.912146629033191e-30




```python
lg.det(C)
```




    143.06836517035583




```python
lg.matrix_rank(A)
```




    3




```python
lg.matrix_rank(B)
```




    3




```python
lg.matrix_rank(C)
```




    3




```python
w,v=lg.eig(B) # W - coбственное значение, а v - собственный вектор
w
```




    array([ 2.45947967e+01,  6.55994066e+00, -9.81747041e-16,  8.86748510e-01,
            1.71958983e-16])




```python
u,z=lg.eig(C) #
u
```




    array([24.59479668,  0.88674851,  6.55994066])



16. Численно посчитать определённый интеграл  3-мя методами:  
a)	Прямоугольников $\int\limits_a^b {f(x)dx \approx \Delta x\sum\limits_{k = 0}^N {f({x_k})} }$  
b)	Трапеций $\int\limits_a^b {f(x)dx \approx \frac{{\Delta x}}{2}\left( {f({x_0}) + 2\sum\limits_{k = 1}^{N - 1} {f({x_k})}  + f({x_N})} \right)}$  
c)	По правилу Симпсона  $\int\limits_a^b {f(x)dx \approx \frac{{\Delta x}}{3}\left( {f({x_0}) + 2\sum\limits_{k = 1}^{N/2 - 1} {f({x_{2k}})}  + 4\sum\limits_{k = 1}^{N/2} {f({x_{2k - 1}})}  + f({x_N})} \right)}$  


В реализации этих методов цикл for для суммирования использовать нельзя.  
Нужно посчитать значение интеграла с некоторым шагом интегрирования (например начать с 0.1), потом уменьшить его в десять раз и ещё раз посчитать и так до тех пор пока отличие в ответах будет в 5-м знаке после запятой, т.е. чтобы ошибка была меньше 1e-5. Получить ответы для 3-х разных методов и сделать соответствующие выводы.  

Далее необходимо сравнить полученные оценки с аналитическим решением (т.е. формульным, которое вы должны сами посчитать на листочке и вбить формулу-ответ).   

В качестве интеграла взять один из следующих с номером, сгенерированным случайным образом с помощью функции np.random.randint(10), в качестве seed для генератора случайных чисел взять номер своего студенческого билета.

<table width="80%"
       align="center">
    <tr>
        <td> 0) $\int\limits_3^4 {\frac{{{x^2} + 3}}{{x - 2}}dx}$ </td>
        <td> 1) $\int\limits_{ - 2}^{ - 1} {\frac{{x + 1}}{{{x^3} - {x^2}}}dx}$ </td>
        <td> 2) $\int\limits_1^2 {\frac{{{e^{1/{x^2}}}}}{{{x^3}}}dx}$ </td>
        <td> 3) $\int\limits_1^e {\frac{{\cos (\ln x)}}{x}dx}$ </td>
        <td> 4) $\int\limits_1^e {\frac{{dx}}{{x(1 + {{\ln }^2}x)}}}$ </td>
    </tr>                
    <tr>
        <td> 5) $\int\limits_0^{\pi /2} {{{\cos }^3}\alpha \;d\alpha }$ </td>
        <td> 6) $\int\limits_0^{1/3} {c{h^2}3x\;dx}$ </td>
        <td> 7) $\int\limits_2^3 {\frac{{dy}}{{{y^2} - 2y - 8}}dy}$ </td>
        <td> 8) $\int\limits_{3/4}^2 {\frac{{dx}}{{\sqrt {2 + 3x - 2{x^2}} }}}$ </td>
        <td> 9) $\int\limits_0^2 {\frac{{2x - 1}}{{2x + 1}}dx}$ </td>
        </tr>
</table>


```python
import numpy as np

np.random.seed(1032216752)
number = np.random.randint(10)
number
```




    9




```python
dx = 0.001
X = np.append(np.arange(0,2,dx),2)
X
```




    array([0.000e+00, 1.000e-03, 2.000e-03, ..., 1.998e+00, 1.999e+00,
           2.000e+00])



X - массив значений х от 0 до 2


```python
def F(x):
    return (2*x-1)/(2*x+1)
J1 = dx*np.sum(F(X)) ## Метод прямоугольника
J1
```




    0.3903617675660328




```python
J2 = (dx/2)*(F(X[0])+2*np.sum(F(X[1:]))+F(X[-1]))
## Метод трапеции
J2
```




    0.39116176756603277




```python
J3 = (dx/3)*(F(X[0])+2*np.sum(F(X[2:-2:2]))+4*np.sum(F(X[1:-1:2]))+F(X[-1])) ## Правило Симпсона
J3
```




    0.3905620875653672



Есть небольшая погрешность в ответах при решении разными способами. При самостоятельном решении получился ответ 2-ln(5), что примерно равно 0,390562088. Наиболее близким к верному значению оказалось правило Симпсона.
